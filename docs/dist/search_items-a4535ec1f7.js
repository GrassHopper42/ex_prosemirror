searchNodes=[{"doc":"ExProsemirror is a helper for the ProseMirror rich-text editor inside of Phoenix.HTML.Form . The current version is in alpha and we don't guarantee it works as expected. EEx examples &lt; % = form_for @changeset , &quot;#&quot; , fn f -&gt; % &gt; &lt; % = prosemirror_input f , :title , type : :title % &gt; &lt; % = prosemirror_input f , :subtitle , type : :title % &gt; &lt; % = prosemirror_input f , :body , type : :content % &gt; &lt; % end % &gt; Assuming we have the following in our config: config :ex_prosemirror , marks_modules : [ em : ExProsemirror.Mark.Em , strong : ExProsemirror.Mark.Strong , underline : ExProsemirror.Mark.Underline ] , blocks_modules : [ p : ExProsemirror.Block.Paragraph , heading : ExProsemirror.Block.Heading , ] , types : [ title : [ marks : [ :em ] , blocks : [ { :heading , [ 1 , 2 ] } ] ] , content : [ marks : [ :strong , :underline ] blocks : [ :paragraph , { :heading , 2 } ] , ] ] We will get the following results: Inputs of type :title will be instantiated with blocks: h1 and h2 marks: em Inputs of type :body will be instantiated with blocks: p and h2 marks: strong and underline The first code sample will create a form with 3 fields: title , subtitle and body . The title will expose italic marks only. The body will expose italic and strong marks plus paragraph and header 1. You can learn more on type in ExProsemirror.Type . &lt; form for = &quot;article&quot; &gt; &lt; input type = &quot;hidden&quot; name = &quot;article[title_plain]&quot; &gt; &lt; div id = &quot;ProseMirrorTitleDiv&quot; &gt; &lt; / div &gt; &lt; input type = &quot;hidden&quot; name = &quot;article[subtitle_plain]&quot; &gt; &lt; div id = &quot;ProseMirrorSubTitleDiv&quot; &gt; &lt; / div &gt; &lt; input type = &quot;hidden&quot; name = &quot;article[body_plain]&quot; &gt; &lt; div id = &quot;ProseMirrorBodyDiv&quot; &gt; &lt; / div &gt; &lt; / form &gt; HTML nodes with id ProseMirror___Div will be updated by the js part to instanciate ExProsemirror js editor. Ecto examples defmodule ExProsemirror.Block.Paragraph do use ExProsemirror.Schema use ExProsemirror import Ecto.Changeset alias ExProsemirror.Block.Text embedded_schema do # Create a embedded ex_prosemirror content and define if it&#39;s an array or not embedded_prosemirror_content ( [ text : Text ] , array : true ) end # opts contains allowed marks def changeset ( struct_or_changeset , attrs \\\\ %{ } , opts \\\\ [ ] ) do struct_or_changeset |&gt; cast ( attrs , [ ] ) # cast_prosemirror_content will cast the embedded schema |&gt; cast_prosemirror_content ( with : [ text : { Text , :changeset , [ opts ] } ] ) end # A callback to return the text of the block def extract_simple_text ( struct ) do Enum . map ( struct . content , &amp; ExProsemirror . extract_simple_text / 1 ) end end To learn more, take a look at ExProsemirror.Schema and ExProsemirror.Changeset . Installation First, you need to add the dependency according to the following code: def deps do [ { :ex_prosemirror , git : &quot;https://github.com/Omerlo-Technologies/ex_prosemirror&quot; , tag : &quot;0.2.0&quot; } , ] end Then, you have to import ExProsemirror.HTML.Form in your views / liveviews This could be done directly in your AppWeb.ex in view/0 and/or live_view/0 . In recent phoenix versions, you could simply add the line in view_helper/0 . defp view_helpers do quote do use Phoenix.HTML import Phoenix.View import ExProsemirror.HTML.Form # &lt;--- this line import AppWeb.ErrorHelpers alias AppWeb.Router.Helpers , as : Routes end end Add the ex_prosemirror dependency to your package.json: { ... &quot;dependencies&quot;: { ... &quot;ex_prosemirror&quot;: &quot;file:../deps/ex_prosemirror/assets&quot; } ... } Finally add ExProsemirrorHooks to phoenix hooks // your hooks . js file import { ExProsemirrorHooks } from &#39;ex_prosemirror/js/hooks&#39; ; const Hooks = { } ; // your hooks export default { ... ExProsemirrorHooks , ... Hooks } ; Optional: If you want to use the default prosemirror css, you can import the css/prosemirror.css file. E.g @import &quot;~ex_prosemirror/css/prosemirror.css&quot;;","ref":"ExProsemirror.html","title":"ExProsemirror","type":"behaviour"},{"doc":"Import ExProsemirror.EctoHelper and add the behaviour of ExProsemirror. Options safe_parser defines if the protocole Pheonix.HTML.Safe should be defined by default. When true , it will use ExProsemirror.extract_simple_text/1 (default: true )","ref":"ExProsemirror.html#__using__/1","title":"ExProsemirror.__using__/1","type":"macro"},{"doc":"Custom changeset defintion for ex_prosemirror. opts contains informations such as marks that defined the marks allowed by the type.","ref":"ExProsemirror.html#c:changeset/3","title":"ExProsemirror.changeset/3","type":"callback"},{"doc":"Setting debug to true will display the hidden form with json structure. By default, this field is input_hidden. Examples debug ( true )","ref":"ExProsemirror.html#debug/1","title":"ExProsemirror.debug/1","type":"function"},{"doc":"Extracts the text(s) value(s) without any text marks / blocks. Examples iex&gt; ExProsemirror . extract_simple_text ( % ExProsemirror.Block.Paragraph { content : [ ...&gt; % ExProsemirror.Block.Text { text : &quot;Hello&quot; } , ...&gt; % ExProsemirror.Block.Text { text : &quot;World&quot; } ...&gt; ] } ) [ &quot;Hello&quot; , &quot;World&quot; ] iex&gt; ExProsemirror . extract_simple_text ( [ ...&gt; % ExProsemirror.Block.Text { text : &quot;Hello&quot; } , ...&gt; % ExProsemirror.Block.Text { text : &quot;World&quot; } ...&gt; ] ) [ &quot;Hello&quot; , &quot;World&quot; ] iex&gt; ExProsemirror . extract_simple_text ( % ExProsemirror.Block.Text { text : &quot;Hello&quot; } ) &quot;Hello&quot;","ref":"ExProsemirror.html#extract_simple_text/1","title":"ExProsemirror.extract_simple_text/1","type":"function"},{"doc":"Override the default extract_simple_text/1 system for the module that implements the callback. Examples def extract_simple_text ( % __MODULE__ { text : text } ) , do : text","ref":"ExProsemirror.html#c:extract_simple_text/1","title":"ExProsemirror.extract_simple_text/1","type":"callback"},{"doc":"ExProsemirror allows an extensible configuration system. You could generate multiples types of configuration depending on your needs. E.g. config :ex_prosemirror , marks_modules : [ # ... ] , blocks_modules : [ # ... heading : ExProsemirror.Block.Heading ] , types : [ title : [ blocks : [ { :heading , [ :h1 ] } ] , marks : [ ] , inline : true ] , subtitle : [ blocks : [ { :heading , [ 2 , 3 ] } ] , marks : [ ] ] ] This will create 2 customs types: title that allows only h1 block without any marks and will be inline. subtitle that allows h2 and h3 blocks and use default marks. Configuration blocks (required) - array of blocks. marks (optional, default: [] ) - array of marks. inline (optional, default: false ) - define if the type is inline.","ref":"ExProsemirror.Config.html","title":"ExProsemirror.Config","type":"module"},{"doc":"Return if the debug mode is enable for ex_prosemirror . true : all ex_prosemirror hidden input will be visible. false (default value): mean hidden input stay hidden for the end user.","ref":"ExProsemirror.Config.html#debug?/0","title":"ExProsemirror.Config.debug?/0","type":"function"},{"doc":"Get the configuration of ExProsemirror","ref":"ExProsemirror.Config.html#load/0","title":"ExProsemirror.Config.load/0","type":"function"},{"doc":"Get the configuration for the specified type. Examples iex&gt; ExProsemirror.Config . load ( :title ) [ inline : true , marks : [ :strong ] , blocks : [ { :heading , [ 1 , 2 ] } , :paragraph ] ]","ref":"ExProsemirror.Config.html#load/1","title":"ExProsemirror.Config.load/1","type":"function"},{"doc":"HTML management of ex_prosemirror.","ref":"ExProsemirror.HTML.html","title":"ExProsemirror.HTML","type":"module"},{"doc":"Render a type to an html element.","ref":"ExProsemirror.HTML.html#html_safe/1","title":"ExProsemirror.HTML.html_safe/1","type":"function"},{"doc":"ExProsemirror's type helpers. A type is composed by blocks and marks . Those elements defined what is allowed in your type. E.g types : [ title : [ blocks : [ { :heading , [ 1 , 3 ] } ] , marks : [ :strong ] ] ] This will createa type title defined by the module ExProsemirror.Type.Title . This type will allow h1 and h3 blocks but also the mark strong . blocks and marks follow the same rules, you can defined them simply with the element name OR with the tuple {element_name, attrs} when attrs depends of the element. You can take a look at ExProsemirror.Mark.Color or ExProsemirror.Block.Heading for examples). As you can see previously, element heading allow attrs 1 and 3 that could be translate as level 1 or level 3 ( h1 or h3 ).","ref":"ExProsemirror.Type.html","title":"ExProsemirror.Type","type":"module"},{"doc":"Changeset used by all ExProsemirror.Type .","ref":"ExProsemirror.Type.html#changeset/3","title":"ExProsemirror.Type.changeset/3","type":"function"},{"doc":"Returns context to use for ExProsemirror types. Examples ExProsemirror.TypeGenerator . get_context ( ) [ marks : [ em : ExProsemirror.Mark.Em , strong : ExProsemirror.Mark.Strong , underline : ExProsemirror.Mark.Underline ] , blocks : [ p : ExProsemirror.Block.Paragraph , heading : ExProsemirror.Block.Heading , image : ExProsemirror.Block.Image , text : ExProsemirror.Block.Text ] ]","ref":"ExProsemirror.Type.html#get_context/0","title":"ExProsemirror.Type.get_context/0","type":"function"},{"doc":"Generate types of ExProsemirror.","ref":"ExProsemirror.TypeGenerator.html","title":"ExProsemirror.TypeGenerator","type":"module"},{"doc":"Generate all types defined in config :exprosemirror , :types .","ref":"ExProsemirror.TypeGenerator.html#generate_all/0","title":"ExProsemirror.TypeGenerator.generate_all/0","type":"macro"},{"doc":"","ref":"ExProsemirror.TypeGenerator.html#get_context/0","title":"ExProsemirror.TypeGenerator.get_context/0","type":"function"},{"doc":"Form helpers to generate HTML fields required by ProseMirror. Using this component, ProseMirror will automatically be link to hidden input fields. These hidden inputs will be used by Phoenix.HTML.Form to send data to the backend. Live synchronization over LiveView is not currently supported. Options marks : mark tags to use defined in your ProseMirror config blocks : block tags to use defined in your ProseMirror config type : type of input to use (see: ExProsemirror.Config for more informations)","ref":"ExProsemirror.HTML.Form.html","title":"ExProsemirror.HTML.Form","type":"module"},{"doc":"Generates the &lt;div&gt; that will be used by javascript to mount the ProseMirror component. Usage &lt; % = prosemirror_editor ( @form , :title ) % &gt; See ExProsemirror.HTML.Form for options","ref":"ExProsemirror.HTML.Form.html#prosemirror_editor/3","title":"ExProsemirror.HTML.Form.prosemirror_editor/3","type":"function"},{"doc":"Generates a hidden input field to store data for ProseMirror. Uses Phoenix.HTML.Form.html.hidden_input/3 under the hood. Usage &lt; % = prosemirror_hidden_input ( @form , :title ) % &gt;","ref":"ExProsemirror.HTML.Form.html#prosemirror_hidden_input/3","title":"ExProsemirror.HTML.Form.prosemirror_hidden_input/3","type":"function"},{"doc":"Generates inputs for ProseMirror. Usages &lt; % = prosemirror_input @form , :title , type : :title , id : &quot;my-article-input&quot; % &gt; # Generates a prosemirror input with the :title configuration. &lt; % = prosemirror_input @form , :title , type : :content , id : &quot;my-article-content&quot; % &gt; # Generates a prosemirror input with the :content configuration. Read ExProsemirror.Config for more information about configuration.","ref":"ExProsemirror.HTML.Form.html#prosemirror_input/3","title":"ExProsemirror.HTML.Form.prosemirror_input/3","type":"function"},{"doc":"HTML encoder protocol for ExProsemirror's struct. Example of implementation alias ExProsemirror.Encoder.HTML , as : HTMLEncoder defimpl HTMLEncoder do def encode ( struct , _opts ) do text = Phoenix.HTML . html_escape ( struct . text ) struct . marks |&gt; Enum . reverse ( ) |&gt; Enum . reduce ( text , fn mark , acc -&gt; HTMLEncoder . encode ( mark , inner_content : acc ) end ) end","ref":"ExProsemirror.Encoder.HTML.html","title":"ExProsemirror.Encoder.HTML","type":"protocol"},{"doc":"Encode the struct to html content. Options inner_content : element to put inside the encoded block / marks.","ref":"ExProsemirror.Encoder.HTML.html#encode/2","title":"ExProsemirror.Encoder.HTML.encode/2","type":"function"},{"doc":"","ref":"ExProsemirror.Encoder.HTML.html#t:t/0","title":"ExProsemirror.Encoder.HTML.t/0","type":"type"},{"doc":"Module helper for Ecto.Changeset.","ref":"ExProsemirror.Changeset.html","title":"ExProsemirror.Changeset","type":"module"},{"doc":"Casts and validates data integrity for an ExProsemirror field type. Examples cast_prosemirror ( changeset , :title , required : true ) % Ecto.Changeset { } Options Same options as ( Ecto.Changeset.cast_embed/3 ]( https://hexdocs.pm/ecto/Ecto.Changeset.html#cast_embed/3 ).","ref":"ExProsemirror.Changeset.html#cast_prosemirror/4","title":"ExProsemirror.Changeset.cast_prosemirror/4","type":"function"},{"doc":"","ref":"ExProsemirror.Changeset.html#update_plain_field/2","title":"ExProsemirror.Changeset.update_plain_field/2","type":"function"},{"doc":"Validates a prosemirror field (returns :__parent__ errors to the field itself). Examples # Assuming changeset contains an ExProsemirror `title` field. struct_or_changeset |&gt; Ecto.Changeset . cast ( %{ title : &quot;Invalid Json&quot; } , [ ] ) |&gt; validate_prosemirror ( changeset , :title , required : true ) % Ecto.Changeset { changes : %{ errors : [ title : &quot;Invalid json&quot; ] } }","ref":"ExProsemirror.Changeset.html#validate_prosemirror/2","title":"ExProsemirror.Changeset.validate_prosemirror/2","type":"function"},{"doc":"Module helper for Ecto.Schema.","ref":"ExProsemirror.Schema.html","title":"ExProsemirror.Schema","type":"module"},{"doc":"Automatically imports ExProsemirror.Schema functions helper. Examples use ExProsemirror.Schema","ref":"ExProsemirror.Schema.html#__using__/1","title":"ExProsemirror.Schema.__using__/1","type":"macro"},{"doc":"Helper to generate ExProsemirror ecto schema field. Examples schema &quot;my_schema&quot; do prosemirror_field :title end # produces field :title_plain , :string , virtual : true embeds_one :title , ExProsemirror.Schema","ref":"ExProsemirror.Schema.html#prosemirror_field/2","title":"ExProsemirror.Schema.prosemirror_field/2","type":"macro"},{"doc":"Ecto schema helper that defines multiple macros to use inside an Ecto.Schema. In contrast of ExProsemirror.Schema , this module should not be imported to your business schema. It MUST be used to create custom block / marks. It helps you build custom blocks / marks for ExProsemirror . This module is automatically import if you use ExProsemirror .","ref":"ExProsemirror.ModifierHelper.html","title":"ExProsemirror.ModifierHelper","type":"module"},{"doc":"Cast prosemirror data struct. Examples struct_or_changeset |&gt; cast ( attrs , some_fields_to_cast ) |&gt; cast_prosemirror_content ( ) # or with opts struct_or_changeset |&gt; cast ( attrs , some_fields_to_cast ) |&gt; cast_prosemirror_content ( with : [ text : { ExProsemirror.Block.Text , :changeset , [ opts ] } ] ) Block ExProsemirror.Block.Text will be cast using the changeset/3 with params %ExProsemirror.Block.Text{...} attrs (map of data to cast) opts: opts to use in the changeset (e.g. allowed marks to cast defined in the ExProsemirror type.) If a block/mark's type is not specified in the with opts, the changeset/2 will be use. Options with : define the changeset to apply, to send allowed marks we recommend to set this element to passed opts .","ref":"ExProsemirror.ModifierHelper.html#cast_prosemirror_content/2","title":"ExProsemirror.ModifierHelper.cast_prosemirror_content/2","type":"function"},{"doc":"","ref":"ExProsemirror.ModifierHelper.html#cast_prosemirror_marks/2","title":"ExProsemirror.ModifierHelper.cast_prosemirror_marks/2","type":"function"},{"doc":"Add the PolymorphicField mark in your ecto schema. Examples embedded_prosemirror_content ( [ text : ExProsemirror.Block.Text ] ) Options array: boolean that defines if we could have multiple elements. Use macro ExProsemirror.SchemaHelper.embedded_prosemirror_field/3 .","ref":"ExProsemirror.ModifierHelper.html#embedded_prosemirror_content/2","title":"ExProsemirror.ModifierHelper.embedded_prosemirror_content/2","type":"macro"},{"doc":"Add the PolymorphicField in your ecto schema. Examples Single element embedded_prosemirror_field ( :content , [ text : ExProsemirror.Block.Text ] , array : false ) # same as embedded_prosemirror_field ( :content , [ text : ExProsemirror.Block.Text ] ) Multiple elements embedded_prosemirror_field ( :content , [ text : ExProsemirror.Block.Text ] , array : true ) Options array : boolean The array option will configure PolymorphicEmbed automatically to be a list of your data OR a single element.","ref":"ExProsemirror.ModifierHelper.html#embedded_prosemirror_field/3","title":"ExProsemirror.ModifierHelper.embedded_prosemirror_field/3","type":"macro"},{"doc":"Add the PolymorphicField mark in your ecto schema. The embedded_field created accepts an array of marks. Examples embedded_prosemirror_mark ( ) Set all marks defined in configs.exs . Use macro ExProsemirror.SchemaHelper.embedded_prosemirror_field/3 .","ref":"ExProsemirror.ModifierHelper.html#embedded_prosemirror_marks/0","title":"ExProsemirror.ModifierHelper.embedded_prosemirror_marks/0","type":"macro"},{"doc":"HTML blocks only contain attrs that defines: html: html content to embed JS Interop When inserting an HTML block, ex_prosemirror will send you a js event. With this event, you'll be able to open your own modal to gather the HTML input. document . querySelectorAll ( &#39;.ex-prosemirror&#39; ) . forEach ( ( el ) =&gt; { el . addEventListener ( &#39;insertPlaceholder&#39; , phoenixHook ) } ) ; Then you will need to send back the content to ex_prosemirror . This is achieved by dispatching an event to the ExEditorView instance. function phoenixHook ( event ) { this . dispatchEvent ( new CustomEvent ( &#39;replacePlaceholder&#39; , { detail : { id : event . detail . id , tr : event . detail . tr , data : { html : &quot;&lt;div style=&#39;color: red;&#39;&gt;Hello World&lt;/div&gt;&quot; } } } ) ) ; }","ref":"ExProsemirror.Block.HTML.html","title":"ExProsemirror.Block.HTML","type":"module"},{"doc":"","ref":"ExProsemirror.Block.HTML.html#t:t/0","title":"ExProsemirror.Block.HTML.t/0","type":"type"},{"doc":"Heading contains multiple ExProsemirror.Block.Text and have attributes that define the level of the heading (between 1 and 6). Usage { :heading , levels } levels is an array of allowed level (between 1 and 6). Examples { :heading , [ 1 , 3 ] }","ref":"ExProsemirror.Block.Heading.html","title":"ExProsemirror.Block.Heading","type":"module"},{"doc":"","ref":"ExProsemirror.Block.Heading.html#t:attrs_level/0","title":"ExProsemirror.Block.Heading.attrs_level/0","type":"type"},{"doc":"","ref":"ExProsemirror.Block.Heading.html#t:t/0","title":"ExProsemirror.Block.Heading.t/0","type":"type"},{"doc":"Image only contains attrs that defines: src: Source of the image alt: Alternate text for an image, if the image cannot be displayed. title: Title of the image JS Interop When inserting an image, ex_prosemirror will send you a js event. With this event, you'll be able to open your own modal for image upload for example. document . querySelectorAll ( &#39;.ex-prosemirror&#39; ) . forEach ( ( el ) =&gt; { el . addEventListener ( &#39;insertPlaceholder&#39; , phoenixHook ) } ) ; Then you will need to send back the content to ex_prosemirror . This is achieved by dispatching an event to the ExEditorView instance. function phoenixHook ( event ) { this . dispatchEvent ( new CustomEvent ( &#39;replacePlaceholder&#39; , { detail : { id : event . detail . id , tr : event . detail . tr , data : { url : &quot;img_src&quot; } } } ) ) ; }","ref":"ExProsemirror.Block.Image.html","title":"ExProsemirror.Block.Image","type":"module"},{"doc":"","ref":"ExProsemirror.Block.Image.html#t:t/0","title":"ExProsemirror.Block.Image.t/0","type":"type"},{"doc":"A paragraph that contains multiple ExProsemirror.Block.Text.","ref":"ExProsemirror.Block.Paragraph.html","title":"ExProsemirror.Block.Paragraph","type":"module"},{"doc":"Callback implementation for ExProsemirror.extract_simple_text/1 .","ref":"ExProsemirror.Block.Paragraph.html#extract_simple_text/1","title":"ExProsemirror.Block.Paragraph.extract_simple_text/1","type":"function"},{"doc":"","ref":"ExProsemirror.Block.Paragraph.html#t:t/0","title":"ExProsemirror.Block.Paragraph.t/0","type":"type"},{"doc":"Prosemirror inline element. It's contained by most of ExProsemirror blocks like ExProsemirror.Block.Paragraph or ExProsemirror.Block.Heading . When creating an ExProsemirror block you can use this module thanks to embedded_prosemirror_content ( [ text : ExProsemirror.Block.Text ] , array : true ) You can also set array to false if you want to inline the block. embedded_prosemirror_content is defined in ExProsemirror.SchemaHelper and is imported with using ExProsemirror.Schema .","ref":"ExProsemirror.Block.Text.html","title":"ExProsemirror.Block.Text","type":"module"},{"doc":"Returns the text of an ExProsemirror.Block.Text . E.g ExProsemirror.Block.Text . extract_simple_text ( % ExProsemirror.Block.Text { text : &quot;Hello elixir&#39;s friends&quot; } ) &quot;Hello elixir&#39;s friends&quot;","ref":"ExProsemirror.Block.Text.html#extract_simple_text/1","title":"ExProsemirror.Block.Text.extract_simple_text/1","type":"function"},{"doc":"","ref":"ExProsemirror.Block.Text.html#t:t/0","title":"ExProsemirror.Block.Text.t/0","type":"type"},{"doc":"Color mark for text. Usage { :color , colors_list } colors_list is a map where keys are the name of the color and the value is the value of the color (could be hex, rgb, or whatever you want). Examples { :color , %{ red : &quot;#ff1111&quot; , blue : &quot;#1111ff&quot; } }","ref":"ExProsemirror.Mark.Color.html","title":"ExProsemirror.Mark.Color","type":"module"},{"doc":"","ref":"ExProsemirror.Mark.Color.html#t:color_value/0","title":"ExProsemirror.Mark.Color.color_value/0","type":"type"},{"doc":"","ref":"ExProsemirror.Mark.Color.html#t:t/0","title":"ExProsemirror.Mark.Color.t/0","type":"type"},{"doc":"Italic mark.","ref":"ExProsemirror.Mark.Em.html","title":"ExProsemirror.Mark.Em","type":"module"},{"doc":"","ref":"ExProsemirror.Mark.Em.html#t:t/0","title":"ExProsemirror.Mark.Em.t/0","type":"type"},{"doc":"Font mark for text. Usage { :font_family , fonts_list } fonts_list is an array of allowed font. Usage { :font_family , [ &quot;verdana&quot; , &quot;Courrier New&quot; ] }","ref":"ExProsemirror.Mark.FontFamily.html","title":"ExProsemirror.Mark.FontFamily","type":"module"},{"doc":"","ref":"ExProsemirror.Mark.FontFamily.html#t:font_value/0","title":"ExProsemirror.Mark.FontFamily.font_value/0","type":"type"},{"doc":"","ref":"ExProsemirror.Mark.FontFamily.html#t:t/0","title":"ExProsemirror.Mark.FontFamily.t/0","type":"type"},{"doc":"Transform a text to a link. inputs opts: marks : [ :link ] JS part We do not provide any JS modal for this mark. You can easily create your own menu item like the following code. export const generateLinkMenuItem = ( schema ) =&gt; { if ( ! schema . marks . link ) { return [ ] ; } return [ new MenuItem ( { title : &#39;Add or remove link&#39; , icon : icons . link , activate ( state ) { return markActive ( state , schema . marks . link ) ; } , enable ( state ) { return ! state . selection . empty ; } , run ( state , dispatch , view ) { // What happen when user click on the menu item button . // You can open a modal , activate / disable the mark ... // Read more on https :// prosemirror . net / if ( markActive ( state , schema . marks . link ) ) { toggleMark ( schema . marks . link ) ( state , dispatch ) ; return true ; } const attrs = { title : &quot;Create a link&quot; , href : &quot;https://your-link-here.com&quot; } toggleMark ( schema . marks . link , attrs ) ( view . state , view . dispatch ) view . focus ( ) } } ) ] ; } Then in the your menu, you can use this function to display the link button.","ref":"ExProsemirror.Mark.Link.html","title":"ExProsemirror.Mark.Link","type":"module"},{"doc":"","ref":"ExProsemirror.Mark.Link.html#changeset/3","title":"ExProsemirror.Mark.Link.changeset/3","type":"function"},{"doc":"","ref":"ExProsemirror.Mark.Link.html#t:href/0","title":"ExProsemirror.Mark.Link.href/0","type":"type"},{"doc":"","ref":"ExProsemirror.Mark.Link.html#t:t/0","title":"ExProsemirror.Mark.Link.t/0","type":"type"},{"doc":"","ref":"ExProsemirror.Mark.Link.html#t:title/0","title":"ExProsemirror.Mark.Link.title/0","type":"type"},{"doc":"Strikethrough mark.","ref":"ExProsemirror.Mark.Strikethrough.html","title":"ExProsemirror.Mark.Strikethrough","type":"module"},{"doc":"","ref":"ExProsemirror.Mark.Strikethrough.html#t:t/0","title":"ExProsemirror.Mark.Strikethrough.t/0","type":"type"},{"doc":"Create heading text style using &lt;b&gt;&lt;/b&gt; html style. inputs opts: marks : [ :strong ]","ref":"ExProsemirror.Mark.Strong.html","title":"ExProsemirror.Mark.Strong","type":"module"},{"doc":"","ref":"ExProsemirror.Mark.Strong.html#t:t/0","title":"ExProsemirror.Mark.Strong.t/0","type":"type"},{"doc":"Create heading text style using &lt;span style=&quot;text-decoration: underline;&quot;&gt;&lt;/span&gt; html style. inputs opts: marks : [ :underline ]","ref":"ExProsemirror.Mark.Underline.html","title":"ExProsemirror.Mark.Underline","type":"module"},{"doc":"","ref":"ExProsemirror.Mark.Underline.html#t:t/0","title":"ExProsemirror.Mark.Underline.t/0","type":"type"},{"doc":"ExProsemirror is a toolkit that integrates the ProseMirror rich-text editor into elixir/phoenix. See the getting started guide and the online documentation for more information.","ref":"readme.html","title":"ExProsemirror","type":"extras"},{"doc":"Add prosemirror_input for phoenix form. Bind prosemirror with your input fields. Keep prosemirror extensible as it is by default.","ref":"readme.html#features","title":"ExProsemirror - Features","type":"extras"},{"doc":"Please see the ExProsemirror Code of Conduct .","ref":"readme.html#contributing","title":"ExProsemirror - Contributing","type":"extras"},{"doc":"As contributors and maintainers of this project, and in the interest of fostering an open and welcoming community, we pledge to respect all people who contribute through reporting issues, posting feature requests, updating documentation, submitting pull requests or patches, and other activities. We are committed to making participation in this project a harassment-free experience for everyone, regardless of level of experience, gender, gender identity and expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion, or nationality. Examples of unacceptable behavior by participants include: The use of sexualized language or imagery Personal attacks Trolling or insulting/derogatory comments Public or private harassment Publishing other's private information, such as physical or electronic addresses, without explicit permission Other unethical or unprofessional conduct Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct. By adopting this Code of Conduct, project maintainers commit themselves to fairly and consistently applying these principles to every aspect of managing this project. Project maintainers who do not follow or enforce the Code of Conduct may be permanently removed from the project team. This code of conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by opening an issue or contacting one or more of the project maintainers. This Code of Conduct is adapted from the Contributor Covenant , version 1.2.0, available at https://www.contributor-covenant.org/version/1/2/0/code-of-conduct.html .","ref":"code_of_conduct.html","title":"Contributor Code of Conduct","type":"extras"},{"doc":"To create a new mark / block , you should first follow prosemirror spec. You can find an example here .","ref":"extends_editor.html","title":"Extends the editor","type":"extras"},{"doc":"In our example, we will have the following mark spec: import exProsemirror from &#39;ex_prosemirror&#39; ; const spanMark = { inline : true , group : &quot;inline&quot; , parseDOM : [ { tag : &quot;span&quot; } ] , toDOM ( ) { return [ &#39;span&#39; , 0 ] } } exProsemirror . setCustomMarks ( { span : spanMark } ) ; exProsemirror . initAll ( ) ; ExProsemirror allows you to add more options in the spec: icon: Object : icon to display in the menu width : size of the svg path : svg definition title: String : Title of the mark in the menu Example import exProsemirror from &#39;ex_prosemirror&#39; ; const spanMark = { inline : true , group : &quot;inline&quot; , parseDOM : [ { tag : &quot;span&quot; } ] , title : &#39;My custom span&#39; , icon : { width : 896 , height : 1024 , path : &quot;M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z&quot; } , toDOM ( ) { return [ &#39;span&#39; , 0 ] } } exProsemirror . setCustomMarks ( { span : spanMark } ) ; exProsemirror . initAll ( ) ;","ref":"extends_editor.html#create-a-custom-span-mark","title":"Extends the editor - Create a custom span mark","type":"extras"},{"doc":"In our example, we will have the following block spec: const spanBlock = { content : &quot;inline*&quot; , group : &quot;block&quot; , parseDOM : [ { tag : &quot;span&quot; } ] , toDOM ( ) { return [ &#39;span&#39; , 0 ] } } ExProsemirror allows you to add more options in the spec: icon: Object : icon to display in the menu width : size of the svg path : svg definition title: String : Title of the mark in the menu label: String : Label to display in the menu If an icon is defined, then the label will not be displayed. Example import exProsemirror from &#39;ex_prosemirror&#39; ; const spanBlock = { content : &quot;inline*&quot; , group : &quot;block&quot; , parseDOM : [ { tag : &quot;span&quot; } ] , title : &#39;my custom span block&#39; , label : &#39;custom span&#39; , icon : { width : 896 , height : 1024 , path : &quot;M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z&quot; } , toDOM ( ) { return [ &#39;span&#39; , 0 ] } } exProsemirror . setCustomBlocks ( { span : spanBlock } ) ; exProsemirror . initAll ( ) ;","ref":"extends_editor.html#create-a-custom-blocks","title":"Extends the editor - Create a custom blocks","type":"extras"}]